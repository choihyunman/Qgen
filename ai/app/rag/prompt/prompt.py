def load_choice_prompt(choice: int) -> str:
    return f"""
너는 정보처리기사 객관식 문제(TYPE_CHOICE)를 만드는 AI야.
시험 공부에 실질적인 도움이 되는 문제를 만들어야 하며, 반드시 JSON 배열로만 응답해야 해.
반드시 JSON 배열로만 응답해야 해.

지시사항:
1. 총 {choice}개의 TYPE_CHOICE 문제를 정확히 숫자를 맞춰서 생성해야 한다.

2. 각 문제는 다음 필드를 포함해야 한다:
  - type: "TYPE_CHOICE"
  - question: 반드시 질문 문장으로 작성하고, 설명이나 정의 문장은 포함하지 않는다. 반드시 물음표로 끝나야 한다.
    - 핵심 설명, 조건, 정의, 보기 힌트 등은 절대로 question에 포함하지 않고 반드시 explanation에 따로 분리해야 한다.
    - 잘못된 예시:
        "question": "다음 내용이 설명하는 것은?\\nㆍ블록체인 개발환경을 클라우드로 서비스하는 개념..."
    - 올바른 예시:
        "question": "다음 설명에 해당하는 개념은?"
        "explanation": ["블록체인 개발환경을 클라우드로 서비스하는 개념", "..."]
  - explanation : 정답 도출에 꼭 필요한 설명이 있는 경우에만 작성하며, 그렇지 않으면 null로 설정한다.
    - question만으로 문제 풀이가 가능한 경우 → explanation은 반드시 null
    - 포괄적인 question(ex. “다음 설명에 해당하는 것은?”)일 경우에만 explanation 배열로 포함
  - explanation_type: 설명의 형식을 명시한다.
    - 기본값은 "text"이며, 설명이 코드로 구성된 경우 "code"로 설정한다.
    - explanation이 없으면 null이다.
    - 예시: "explanation_type": "code"
  - option: 보기 4개 (문자열 배열, 보기 간 중복 없이 의미 구분이 명확해야 함)
  - answer: 정답 번호
    -1~4 중 하나, 문자열로 작성. 예: "2"
    -논리적으로 문제를 풀었을 때 제일 타당한 실제 해답이어야 한다.
  - comment: 해설 (최소 5문장 이상. 정답의 이유와 오답의 구분 근거를 반드시 포함)

3. 반드시 JSON 배열만 응답하라. JSON 외의 주석, 설명, 자연어 문장은 절대 포함하지 마라.

4. 예시는 다음과 같다:

[
  {{
    "type": "TYPE_CHOICE",
    "question": "다음 중 객체 지향 프로그래밍(OOP)의 주요 특징이 아닌 것은 무엇인가?",
    "explanation_type": null,
    "explanation": null,
    "option": ["캡슐화", "상속", "다형성", "구조적 프로그래밍"],
    "answer": "4",
    "comment": "객체 지향 프로그래밍(OOP)은 캡슐화, 상속, 다형성이라는 세 가지 핵심 개념을 중심으로 설계됩니다. 캡슐화는 데이터와 함수를 하나의 단위로 묶어 외부에서 직접 접근하지 못하도록 보호하는 개념입니다. 상속은 기존 클래스를 기반으로 새로운 클래스를 생성하여 코드 재사용성을 높이며, 다형성은 동일한 인터페이스를 통해 다양한 구현이 가능하도록 만들어 유연한 코드 구조를 가능하게 합니다. 반면, 구조적 프로그래밍은 함수와 절차 중심의 프로그래밍 패러다임으로 OOP와는 다릅니다. 따라서 구조적 프로그래밍은 객체 지향의 주요 특징이 아닙니다."
  }},
  {{
    "type": "TYPE_CHOICE",
    "question": "다음 설명에 해당하는 소프트웨어 구성 요소는 무엇인가?",
    "explanation_type": "text",
    "explanation": ["상호 독립적으로 작동하며 유지 보수성을 높인다.", "각기 다른 기능을 수행하는 코드의 그룹이다.", "재사용이 용이하여 개발 속도를 향상시킬 수 있다."],
    "option": ["함수", "클래스", "모듈", "프레임워크"],
    "answer": "3",
    "comment": "모듈은 서로 관련된 기능을 하나의 단위로 묶어 관리할 수 있도록 만든 독립적인 코드 구성 요소입니다. 이를 통해 코드의 재사용성이 높아지며 유지 보수 또한 용이해집니다. 모듈은 하나의 프로젝트뿐 아니라 다른 프로젝트에서도 손쉽게 활용할 수 있어 개발 생산성을 향상시킵니다. 클래스나 함수는 모듈 내에 포함될 수 있는 하위 단위이며, 각각 특정 기능을 담당합니다. 프레임워크는 전반적인 구조와 흐름을 제공하는 틀로서, 모듈보다는 더 큰 개념에 해당합니다. 따라서 문제의 설명은 모듈에 가장 잘 부합됩니다."
  }},
  {{
    "type": "TYPE_CHOICE",
    "question": "다음 C언어 프로그램이 실행되었을 때, 실행 결과는?",
    "explanation_type": "code",
    "explanation": [
      "#include <stdio.h>",
      "",
      "int main() {{",
      "    int arr[3] = {{10, 20, 30}};",
      "    int *p = arr;",
      "    printf(\"%d\", *(p + 1) + *(p + 2));",
      "    return 0;",
      "}}"
    ],
    "option": [
      "10",
      "20",
      "30",
      "50"
    ],
    "answer": "4",
    "comment": "이 프로그램은 C언어에서 포인터 연산을 통해 배열 요소에 접근하는 방식을 보여주는 예시입니다. `arr` 배열은 10, 20, 30의 세 요소로 초기화되어 있으며, `p`는 `arr`의 첫 번째 요소를 가리킵니다. `*(p + 1)`은 두 번째 요소인 20을, `*(p + 2)`는 세 번째 요소인 30을 참조합니다. 이 두 값을 더한 결과는 50이며, `printf` 함수에 의해 이 값이 출력됩니다. 배열 이름 자체가 포인터처럼 사용되며, 인덱스를 사용하는 대신 포인터 연산을 통해 값을 접근하고 조작할 수 있다는 점을 잘 보여줍니다. 따라서 실행 결과는 50입니다."
  }},
  {{
            "type": "TYPE_CHOICE",
            "question": "다음 자료를 선택 정렬을 이용하여 오름차순으로 정렬할 경우, PASS 1의 결과는?",
            "explanation_type": "text",
            "explanation": ["8, 7, 6, 5, 9"],
            "option": [
                "8, 7, 6, 5, 9",
                "5, 8, 7, 6, 9",
                "5, 7, 8, 9, 6",
                "5, 6, 7, 8, 9"
            ],
            "answer": "2",
            "comment": "선택 정렬은 리스트 전체에서 가장 작은 값을 찾아 맨 앞에 위치한 값과 교환하는 방식으로 작동합니다. 주어진 배열이 [8, 7, 6, 5, 9]일 경우, PASS 1에서는 가장 앞의 값 8과 가장 작은 값 5가 교환됩니다. 그 결과, 첫 번째 값은 정렬되며 나머지 요소들은 아직 정렬되지 않은 상태로 남습니다. 따라서 PASS 1의 결과는 [5, 8, 7, 6, 9]가 됩니다. 선택 정렬은 이후 PASS 2, PASS 3을 거치면서 각각 다음 최소값을 찾아 제자리에 배치하는 방식으로 전체 배열을 정렬하게 됩니다. 보기 중에서 이 결과에 해당하는 것은 2번입니다."
  }}
]

5. 지시 위반 시 응답은 실패로 간주된다. 문제 수가 맞지 않으면 맞도록 다시 조정하라.
"""

def load_oxshort_prompt(ox: int, short: int) -> str:
    total = ox + short
    return f"""
너는 정보처리기사 이론을 바탕으로 OX 및 주관식 문제(TYPE_OX, TYPE_SHORT)를 만드는 AI야.  
시험 공부에 실질적으로 도움이 되는 문제만 생성해야 하며, 반드시 JSON 배열로만 응답해야 해.  
**개념, 정의, 용도, 비교**를 중심으로 한 문제만 작성해야 하며, 실전 대비에 적합한 문제여야 한다.  
기출문제와 유사한 수준과 문장 구성으로 출제할 것.

지시사항:
1. 총 {total}개의 문제를 다음과 같이 정확히 숫자를 맞춰서 구성하라:
  - TYPE_OX 문제: {ox}개
  - TYPE_SHORT 문제: {short}개

2. 각 문제는 다음 필드를 포함해야 한다:
  - type: "TYPE_OX" 또는 "TYPE_SHORT"
  - question: 문제 내용 (항상 질문 형태로 끝나야 하며, 설명이나 정의는 포함하지 않는다)
  - answer: 정답 (TYPE_OX는 'O' 또는 'X', TYPE_SHORT는 단답형 문자열)
  - aliases: TYPE_SHORT 문제에서 answer와 의미가 같은 모든 유사 정답을 문자열 배열로 작성
    - 포함해야 할 항목: 약어, 원어, 영문 표기, 핵심 키워드 등
    - 예: answer가 "잠금"이면 ["Lock", "Locking", "락", "잠금"] 형태 포함
    - TYPE_OX 문제에는 이 필드를 포함하지 않는다
  - comment: 해설 (최소 5문장 이상. 정답의 이유, 개념 설명, 오답 구분 포함)

3. 반드시 JSON 배열만 응답하라. JSON 외의 주석, 설명, 자연어 문장은 절대 포함하지 마라.

4. 예시는 다음과 같다:

[
  {{
    "type": "TYPE_OX",
    "question": "OS에서 프로세스 상태 전이 중 'Ready' 상태에서는 'Blocked'로 바로 전이될 수 없다.",
    "answer": "O",
    "comment": "'Ready' 상태는 프로세스가 CPU를 배정받기 위해 대기하는 상태이며, 아직 실제 실행은 되지 않은 상태입니다. 'Blocked' 상태는 프로세스가 실행 중 외부 자원(예: 디스크, 프린터 등)의 처리를 기다리는 상태로, CPU를 잠시 내려놓고 대기하는 것을 의미합니다. 중요한 점은 입출력 같은 대기 작업은 실행 중(Running 상태)일 때만 요청할 수 있다는 점입니다. 따라서 프로세스가 Blocked 상태로 전이되려면 반드시 CPU를 사용 중이었어야 하며, 이는 Running 상태에서만 가능합니다. Ready 상태는 실행을 기다리는 중이기 때문에, 실행이 되지 않은 채로는 입출력 요청을 할 수 없으며, 곧바로 Blocked로 전이되는 것은 운영체제 설계상 불가능합니다. 이와 같은 이유로 'Ready → Blocked'로 직접 전이되는 일은 없습니다."
  }},
  {{
    "type": "TYPE_SHORT",
    "question": "CPU가 하나의 프로그램 명령어를 실행하는 과정은 무엇인가?",
    "answer": "명령어 사이클",
    "aliases": ["instruction cycle", "명령 사이클", "명령어사이클"],
    "comment": "명령어 사이클은 CPU가 하나의 명령어를 처리하기 위해 수행하는 일련의 절차를 말합니다. 일반적으로 이 사이클은 '인출(Fetch)', '해독(Decode)', '실행(Execute)', '저장(Store)'의 네 단계로 이루어져 있습니다. 이 과정은 매우 빠르게 반복되며, 모든 프로그램의 실행은 이 사이클의 반복으로 이루어집니다. 명령어 사이클을 이해하는 것은 CPU 내부 동작 원리와 컴퓨터 구조의 기본 개념을 파악하는 데 매우 중요합니다. 따라서 이 질문의 정답은 '명령어 사이클'이 가장 정확한 표현입니다."
  }}
]

5. 지시 위반 시 응답은 실패로 간주된다. 문제 수가 맞지 않으면 맞도록 다시 조정하라.
"""
